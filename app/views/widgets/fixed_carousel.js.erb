
function cspInitFixedCarousel ($, $container) {

  if (getCookie('cs-fixed-carousel-removed')) return false;

  var widgetShowTimer, widgetHideTimer,
      attachListeners = function () {
        scrollListeners($container);
        $container
          .on('click', '.cs-header', function (e, data) {
            var auto = data && data.isAuto;
            if ($(e.target).is('[class*="remove"]')) {
              $container.hide();
              // set a cookie to keep the widget hidden for a day
              var date = new Date();
              setCookie('cs-fixed-carousel-removed', '1', date.setDate(date.getDate() + 1), '/', window.location.hostname);
              return false;
            }
            if (!auto) {
              // cancel the timers if user interacts with widget
              if (widgetShowTimer) { clearTimeout(widgetShowTimer); }
              if (widgetHideTimer) { clearTimeout(widgetHideTimer); }
            }
          });
      };

  setScrollBoundaries();
  attachListeners();
  initWidgetAuto();
  $container.find('section')
            .slideDrawer()
            .css({ opacity: 0, visibility: "visible" })
            .animate({ opacity: 1 }, 200);

  function initWidgetAuto () {
    if (<%= @company.widget.show %> && !getCookie('cs-fixed-carousel-hide') ) {
      widgetShowTimer = setTimeout(function () {
        $container.find('header').trigger('click', { isAuto: true } );
        if (<%= @company.widget.hide %>) {
          widgetHideTimer = setTimeout(function () {
            $container.find('header').trigger('click', { isAuto: true } );
          }, <%= @company.widget.hide_delay %>);
        }
      }, <%= @company.widget.show_delay %>);
      // widget is configured to auto-open once per widget.show_freq days ...
      var date = new Date();
      date.setDate(date.getDate() + <%= @company.widget.show_freq %>);
    }
  }

  function setCookie (name, value, expires, path, domain, secure) {
    document.cookie = name + "=" + escape(value) +
      ((expires) ? "; expires=" + expires : "") +
      ((path) ? "; path=" + path : "") +
      ((domain) ? "; domain=" + domain : "") +
      ((secure) ? "; secure" : "");
  }

  function getCookie (name) {
    var cookie = " " + document.cookie;
    var search = " " + name + "=";
    var setStr = null;
    var offset = 0;
    var end = 0;
    if (cookie.length > 0) {
      offset = cookie.indexOf(search);
      if (offset != -1) {
        offset += search.length;
        end = cookie.indexOf(";", offset);
        if (end == -1) {
          end = cookie.length;
        }
        setStr = unescape(cookie.substring(offset, end));
      }
    }
    return(setStr);
  }

  function scrollListeners ($container) {

    var $carousel = $container.find('.row-horizon'),
        $paginationContainer = $container.find('.cs-pagination-row'),
        scrollWidth = $carousel.prop('scrollWidth'),
        maxScrollPosition = scrollWidth - $carousel.width(),
        numPages = Math.ceil(scrollWidth / $carousel.width()),
        pageWidth = Math.ceil(scrollWidth / numPages),
        currentPage = 1,
        scrollPosition = null, scrollRemaining = null,
        dynamicPage = null, lastPage = null,
        calculateDynamicPage = function (position, numPages, pageWidth, carouselWidth) {
          for (var i = 1; i <= numPages; i++) {
            if (position + (carouselWidth / 2) < pageWidth * i) { return i; }
          }
        },
        paginationTrackScroll = function () {
          dynamicPage =
            calculateDynamicPage($(this).scrollLeft(), numPages, pageWidth, $(this).width());
          if (dynamicPage !== currentPage) {
            lastPage = currentPage;
            currentPage = dynamicPage;
            $paginationContainer.find('div:nth-of-type(' + lastPage.toString() + ')')
                                .removeClass('cs-current-page-dot');
            $paginationContainer.find('div:nth-of-type(' + currentPage.toString() + ')')
                                .addClass('cs-current-page-dot');
          }
        },
        paginationScroll = function ($carousel, pageWidth, paginationTrackScroll) {
          // $(this) refers to the div.page-dot clicked
          return function (e) {
            var goToPage = null, scrollTo = null;

            if ($(this).hasClass('cs-current-page-dot')) { e.preventDefault(); }

            // turn off other handlers until animation is complete
            $carousel.off('scroll', paginationTrackScroll);
            // .. but not the currently executing handler ... things get weird
            // $('.cs-page-dot').off('click', paginationScroll)

            $(this).addClass('goto-page-dot');
            $container.find('.cs-current-page-dot').removeClass('cs-current-page-dot');
            $container.find('.cs-page-dot').each(function (index, pageDot) {
              if ($(this).hasClass('goto-page-dot')) {
                scrollTo = index * pageWidth;
                $(this).addClass('cs-current-page-dot')
                       .removeClass('goto-page-dot');
                return false;
              }
            });
            $carousel.animate({ scrollLeft: scrollTo }, 1000, function () {
              $carousel.on('scroll', paginationTrackScroll);
            });
          };
        },
        arrowScrollLeft = function ($carousel, pageWidth) {
          return function (e) {
            var scrollPosition = $carousel.scrollLeft(),
                $pageDots = $container.find('.cs-page-dot');
            $pageDots.off('click', paginationScroll);
            if (scrollPosition >= pageWidth) {
              $carousel.animate({ scrollLeft: '-=' + pageWidth.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
            else {
              $carousel.animate({ scrollLeft: '-=' + scrollPosition.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
          };
        },
        arrowScrollRight = function ($carousel, pageWidth, scrollWidth) {
          return function (e) {
            var scrollPosition = $carousel.scrollLeft(),
                scrollRemaining = scrollWidth - (scrollPosition + $carousel.width()),
                $pageDots = $container.find('.cs-page-dot');
            $pageDots.off('click', paginationScroll);
            if (scrollRemaining >= pageWidth) {
              $carousel.animate({ scrollLeft: '+=' + pageWidth.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            } else {
              $carousel.animate({ scrollLeft: '+=' + scrollRemaining.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
          };
        };

    // set up pagination
    for (var i = 0; i < numPages; i++) {
      if (i === 0) {
        $paginationContainer
          .append("<div class='cs-page-dot cs-current-page-dot'></div>");
      } else {
        $paginationContainer
          .append("<div class='cs-page-dot'></div>");
      }
    }

    if (numPages > 1) {

      $carousel.on('scroll', paginationTrackScroll);
      $container.find('.cs-scroll-left')
        .on('click', arrowScrollLeft($carousel, pageWidth));
      $container.find('.cs-scroll-right')
        .on('click', arrowScrollRight($carousel, pageWidth, scrollWidth));
      $container.find('.cs-page-dot')
        .on('click', paginationScroll($carousel, pageWidth, paginationTrackScroll));

    } else {
      $container.find('.cs-pagination-row, .cs-scroll-left, .cs-scroll-right')
        .css('visibility', 'hidden');
    }
  }

  /*
    when scrolling past boundaries with trackpad, prevent default browser behavior
    (back/forward navigation)
  */
  function setScrollBoundaries () {
    // constraign trackpad scrolling (don't go forward/back in browser)
    var maxX = null;
    $(document).on('wheel',
      '#cs-container .row-horizon, #cs-tab-container .row-horizon, #cs-fixed-carousel .row-horizon',
      function (event) {
        maxX = $(this).prop('scrollWidth') - $(this).prop('offsetWidth');
        // If this event looks like it will scroll beyond the bounds of the element,
        //  prevent it and set the scroll to the boundary manually
        if ($(this).prop('scrollLeft') + event.originalEvent.deltaX < 0 ||
            $(this).prop('scrollLeft') + event.originalEvent.deltaX > maxX) {
          event.preventDefault();
          $(this).prop('scrollLeft', Math.max(0, Math.min(maxX, $(this).prop('scrollLeft') + event.originalEvent.deltaX)));
        }
      }
    );
  }

}