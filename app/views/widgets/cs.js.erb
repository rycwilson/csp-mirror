(function (window, document) {
  "use strict";
  var jQuery, $; // localize jquery variables

  if (window.jQuery === undefined || isOldVersion(window.jQuery.fn.jquery)) {
    loadScript("https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js",
      function () {
        /* Restore $ and window.jQuery to their previous values and store the
           new jQuery in our local jQuery variables. */
        $ = jQuery = window.jQuery.noConflict(true);
        main();
      });
  } else {
    $ = jQuery = window.jQuery;
    main();
  }

  function main () {

    $(function () {
      var type = '<%= @type %>', $container,
          $script = (type === 'tab') ? $('script[href*="tab"]') :
                      (type === 'rel' ? $('script[href*="rel/"]') : $('script[href*="rel-exp"]')),
          category = $script.data('category'),
          product = $script.data('product'),
          $stylesheet = $("<link>", { rel: "stylesheet", type: "text/css" });

      if (type === 'tab') {
        $container = $('#cs-container').length ? $('#cs-container') : $('#cs-tab-container');
        $stylesheet.attr('href', "<%= URI.join(root_url, asset_path('cs-widget-tab.css')) %>");
      } else if (type === 'rel') {
        $container = $('#cs-rel-container');
        $stylesheet.attr('href', "<%= URI.join(root_url, asset_path('cs-widget-rel.css')) %>");
      } else if (type === 'rel-exp') {
        $container = $('#cs-rel-exp-container');
        $stylesheet.attr('href', "<%= URI.join(root_url, asset_path('cs-widget-rel-exp.css')) %>");
      } else if (type === 'varmour') {
        $container = $('#cs-varmour-container');
        $stylesheet.attr('href', "<%= URI.join(root_url, asset_path('cs-widget-varmour.css')) %>");
      }

      // get font awesome if it doesn't exist on host
      $("<link>", {
        rel: "stylesheet",
        type: "text/css",
        href: "https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
      }).appendTo('head');

      // wait for stylesheet to load ...
      $stylesheet.appendTo('head').on('load', function () {

        $.ajax({
          url: "<%= URI.join(root_url, widget_html_path(@type)) %>",
          dataType: 'jsonp',
          data: {
            category: category,
            product: product
          },
          success: function (data) {
            $container.html(data.html);
            // wait for all images to load so dimension calculations are correct ...
            var $images = $container.find('img'), loadedImages = 0;
            $images.on('load', function () {
              if (++loadedImages === $images.length) {
                if (type === 'tab') {
                  buildTabWidget($container);
                  scrollHandlers($container);
                } else if (type === 'rel') {
                  buildRelWidget($container);
                  scrollHandlers($container);
                } else if (type === 'rel-exp') {
                  buildRelExpWidget($container);
                  scrollHandlersExp($container);
                } else if (type === 'varmour') {
                  buildVarmourWidget($container);
                }
                xScrollBoundaries(type);
              }
            })
          }
        }); // ajax

      });
    });
  }

  function buildRelWidget ($container) {
    $container.find('.cs-thumbnail.published').hover(
      function () { $(this).css('border-color', '<%= @company.widget.tab_color %>'); },
      function () { $(this).css('border-color', '#ddd'); }
    );
    $container.find('.cs-thumbnail.logo-published').hover(
      function () { $(this).css('border-color', '#ccc'); },
      function () { $(this).css('border-color', '#ddd'); }
    );
    $container.find('section').css('visibility', 'visible');
    if (<%= ENV['HOST_NAME'] == 'customerstories.net' %>) {
      trackVisitor();
    }
  }

  function buildRelExpWidget ($container) {
    var borderColorHex = '<%= @company.widget.tab_color %>',
        borderColorRgb = hexToRgb(borderColorHex),
        borderOpacity = 0.8,
        borderColorRgba = 'rgba(' + borderColorRgb.r.toString() + ',' + borderColorRgb.g.toString() + ',' + borderColorRgb.b.toString() + ',' + borderOpacity.toString()

    // disable horizontal scrolling
    $container.find('.row-horizon').css('overflow-x', 'hidden');

    $container.find('.cs-thumbnail').css('border-color', borderColorHex);
    $container.find('.cs-caption').css('background-color', borderColorHex);

    textfillPlugin();
    $container.find('.cs-caption').each(function () {
      $(this).textfill({ minFontPixels: 12, maxFontPixels: 16 });
    })

    // alter caption text on hover
    $container.find('.cs-thumbnail.published, .cs-thumbnail.preview-published')
      .hover(
        function () {
          var $thumbnail = $(this);
          setTimeout(function () {
            $thumbnail.find('.cs-caption').children().toggle();
          }, 200);  // matches logo transition
        },
        function () {
          var $thumbnail = $(this);
          // setTimeout(function () {
            $thumbnail.find('.cs-caption').children().toggle();
          // }, 200);  // matches logo transition
        }
      );

    // column widths responsive to screen width;
    // adjust as necessary on page load and device orientation change
    adjustColumnsWidth($container);
    $(window).on('orientationchange', function () {
      adjustColumnsWidth($container);
    })

    $container.find('section').css('visibility', 'visible');
    if (<%= ENV['HOST_NAME'] == 'customerstories.net' %>) {
      trackVisitor();
    }
  }

  function buildVarmourWidget ($container) {
    // alternative font for test environment
    varmourAltFont();
    // disable horizontal mouse/trackpad scrolling
    $container.find('.row-horizon').css('overflow-x', 'hidden');

    var $carousel = $container.find('.row-horizon'),
        $columns = $carousel.children(),
        $stories = $columns.children(),
        storyWidth = parseInt( $stories.first().css('width'), 10 ) +
                     parseInt( $columns.first().css('padding-left'), 10 ) +
                     parseInt( $columns.first().css('padding-right'), 10 ),
        $pagination = $container.find('.cs-pagination'),
        $paginationXs = $container.find('.cs-pagination-xs'),
        currentStoryIndex,  // this is set before adjusting
        numPages, pageWidth,  // these are set after adjusting
        currentPage = 0,  // 0-based paging
        initialAdjust = true,
        currentDevice = $(window).width() < 768 ? 'xs' :
                         ( $(window).width() < 992 ? 'sm' :
                           ( $(window).width() < 1200 ? 'md' : 'lg' ) ),
        arrowLeft = function () {
          if (currentPage !== 0) {
            currentPage -= 1;
            var scrollTime = Math.round($carousel.width() / 2);
            [ $pagination, $paginationXs ].forEach(function ($p) {
              $p.children('.cs-current-page-dot').removeClass('cs-current-page-dot');
              $p.children().eq(currentPage).addClass('cs-current-page-dot');
            });
            $carousel.animate({ scrollLeft: '-=' + $carousel.css('width') }, scrollTime);
          }
        },
        arrowRight = function () {
          if (currentPage !== numPages - 1) {
            currentPage += 1;
            var scrollTime = Math.round($carousel.width() / 2);
            [ $pagination, $paginationXs ].forEach(function ($p) {
              $p.children('.cs-current-page-dot').removeClass('cs-current-page-dot');
              $p.children().eq(currentPage).addClass('cs-current-page-dot');
            });
            $carousel.animate({ scrollLeft: '+=' + $carousel.css('width') }, scrollTime);
          }
        },
        adjustColumns = function () {
          var device = $(window).width() < 768 ? 'xs' :
                     ( $(window).width() < 992 ? 'sm' :
                       ( $(window).width() < 1200 ? 'md' : 'lg' ) )
          if (device !== currentDevice) {
            currentDevice = device;
            $stories.css('margin', '0 auto');
          }
          // need to capture the current story so we can scroll to it after adjusting
          var currentStoryIndex = Math.floor($carousel.prop('scrollLeft') / $columns.first().outerWidth());

          if ($carousel.width() >= 4 * storyWidth) {
            // in case margins were adjusted (when displaying two stories), adjust them back
            $stories.css('margin', '0 auto');
            $columns.css('width', Math.floor($carousel.width() / 4).toString() + 'px')
            if ($columns.length <= 4) {
              $container.find('.cs-scroll div').hide();
            }

          } else if ($carousel.width() >= 3 * storyWidth) {
            // in case margins were adjusted (when displaying two stories), adjust them back
            $stories.css('margin', '0 auto');
            $columns.css('width', Math.floor($carousel.width() / 3).toString() + 'px')
            if ($columns.length <= 3) {
              $container.find('.cs-scroll div').hide();
            }

          } else if ($carousel.width() >= 2 * storyWidth) {
            if ($columns.length <= 2) {
              $container.find('.cs-scroll div').hide();
            }
            // adjust column size
            $columns.css('width', Math.floor($carousel.width() / 2).toString() + 'px')
            // adjust story margins (squish them together) if gutter too big
            var minGutterWidth = 80,
                actualGutterWidth = $columns.first().outerWidth() - $stories.first().width(),
                gutterDelta = (actualGutterWidth - minGutterWidth) / 2;
            if (actualGutterWidth > minGutterWidth) {
              // if odd number of stories, give last one full width and don't adjust margin below
              var lastIsSingle = $columns.length % 2 !== 0;
              if (lastIsSingle) {
                $columns.last().css('width', $carousel.width());
              }
              $stories.each(function (index, column) {
                if (lastIsSingle && index === $stories.length - 1) {
                  // do nothing
                } else {  // per specs of max gutter 70px
                  $(this).css('margin-' + (index % 2 === 0) ? 'right' : 'left', '35px');
                }
              });
            }

          } else {
            // in case margins were adjusted (when displaying two stories), adjust them back
            $stories.css('margin', '0 auto');
            $columns.css('width', $carousel.css('width'))
            if ($columns.length === 1) {
              $container.find('.cs-scroll div').hide();
            }
          }

          // scroll to current story (wherever previous scroll was)
          $carousel.prop('scrollLeft', currentStoryIndex * $columns.first().outerWidth());
          // update number of pages
          numPages = Math.ceil($carousel.prop('scrollWidth') / $carousel.width());
          // reset pagination if this is a resize
          if (!initialAdjust) {
            pageWidth = Math.floor($carousel.prop('scrollWidth') / numPages);
            currentPage = Math.floor($carousel.prop('scrollLeft') / pageWidth);
            [ $pagination, $paginationXs ].forEach(function ($p) {
              $p.empty();
            });
            if (numPages > 8 && $(window).width() <= 500) {
              $paginationXs
                .append('<span style="color: #999">' +
                          (currentPage + 1).toString() + ' of ' + numPages.toString() +
                        '</span>');
            } else if ($(window).width() <= 500) {
              for (var i = 0; i < numPages; i++) {
                if (i === currentPage) {
                  $paginationXs.append("<div class='cs-page-dot cs-current-page-dot'></div>");
                } else {
                  $paginationXs.append("<div class='cs-page-dot'></div>");
                }
              }
            } else {
              for (var i = 0; i < numPages; i++) {
                if (i === currentPage) {
                  $pagination.append("<div class='cs-page-dot cs-current-page-dot'></div>");
                } else {
                  $pagination.append("<div class='cs-page-dot'></div>");
                }
              }
            }
          }
          initialAdjust = false;
        }; // adjust columns

    // animate stories
    varmourHover($stories);

    // scroll listeners
    $container.find('.cs-scroll-left, .cs-scroll-xs-left').on('click', arrowLeft);
    $container.find('.cs-scroll-right, .cs-scroll-xs-right').on('click', arrowRight);

    // initial adjustment
    adjustColumns();

    // set up pagination (numPages calculation needs to be after adjustment)
    numPages = Math.ceil($carousel.prop('scrollWidth') / $carousel.width());
    if (numPages > 8 && $(window).width() <= 500) {
      $paginationXs
        .append('<span style="color:#999">' +
                  (currentPage + 1).toString() + ' of ' + numPages.toString() +
                '</span>');
    } else if ($(window).width() <= 500) {
      for (var i = 0; i < numPages; i++) {
        if (i === 0) {
          $paginationXs.append("<div class='cs-page-dot cs-current-page-dot'></div>");
        } else {
          $paginationXs.append("<div class='cs-page-dot'></div>");
        }
      }
    } else {
      for (var i = 0; i < numPages; i++) {
        if (i === 0) {
          $pagination.append("<div class='cs-page-dot cs-current-page-dot'></div>");
        } else {
          $pagination.append("<div class='cs-page-dot'></div>");
        }
      }
    }

    // make adjustments on window resize
    // ref: https://stackoverflow.com/questions/599288
    var resizeTimer;
    var resizeCallback = function () {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(adjustColumns, 100);
    };
    $(window).on('resize', resizeCallback);
    $(window).on('orientationchange', adjustColumns);

    // turn on the widget, enable tracking
    $container.find('section').css('visibility', 'visible');
    if (<%= ENV['HOST_NAME'] == 'customerstories.net' %>) {
      trackVisitor();
    }
  }

  // on weebly, get the Montserrat font to emulate proxima-nova
  function varmourAltFont () {
    if (window.location.href.includes('weebly')) {
      $("<link>", {
        rel: "stylesheet",
        type: "text/css",
        href: "//fonts.googleapis.com/css?family=Montserrat:300,600"
      }).appendTo('head');
    }
  }

  // doing this in js so we can have timeout delay in one direction only
  function varmourHover ($stories) {
    $stories.hover(
      function () {
        var $story = $(this);
        setTimeout(function () {
          $story.find('.cs-caption').children().toggle();
        }, 300);
      },
      function () {
        $(this).find('.cs-caption').children().toggle();
      }
    )
  }

  function buildTabWidget ($container) {
    slideDrawerPlugin($container);
    var $header = $container.find('.cs-header'),
        widgetShowTimer = null, widgetHideTimer = null;
    // cancel the timers if user interacts with widget
    $header.on('click', function (e, data) {
      var auto = data && data.isAuto;
      if (!auto) {
        if (widgetShowTimer) { clearTimeout(widgetShowTimer); }
        if (widgetHideTimer) { clearTimeout(widgetHideTimer); }
      }
    });
    if ( <%= @company.widget.show %> && !getCookie('cs-widget-hide') ) {
      widgetShowTimer = setTimeout(function () {
        $header.trigger('click', { isAuto: true } );
        if (<%= @company.widget.hide %>) {
          widgetHideTimer = setTimeout(function () {
            $header.trigger('click', { isAuto: true } );
          }, <%= @company.widget.hide_delay %>);
        }
      }, <%= @company.widget.show_delay %>);
      var date = new Date();
      date.setDate(date.getDate() + <%= @company.widget.show_freq %>);
      setCookie('cs-widget-hide', '1', date.toUTCString())
    }
    $container.find('.cs-thumbnail.published').hover(
      function () { $(this).css('border-color', '<%= @company.widget.tab_color %>'); },
      function () { $(this).css('border-color', 'rgba(0, 0, 0, 0.7)'); }
    );
    $container.find('.cs-thumbnail.logo-published').hover(
      function () { $(this).css('border-color', '#ccc'); },
      function () { $(this).css('border-color', 'rgba(0, 0, 0, 0.7)'); }
    );
    $container.find('section')
      .slideDrawer()
      .css({ opacity: 0, visibility: "visible" })
      .animate({ opacity: 1 }, 200);
    if (<%= ENV['HOST_NAME'] == 'customerstories.net' %>) {
      trackVisitor();
    }
  }

  // slideout drawer plugin
  function loadScript (url, callback) {
    var scriptTag = document.createElement('script');
    scriptTag.setAttribute("type", "text/javascript");
    scriptTag.setAttribute("src", url);
    if (typeof callback !== "undefined") {
      if (scriptTag.readyState) {
        /* For old versions of IE */
        scriptTag.onreadystatechange = function () {
          if (this.readyState === 'complete' || this.readyState === 'loaded') {
            callback();
          }
        };
      } else {
        scriptTag.onload = callback;
      }
    }
    (document.getElementsByTagName("head")[0] || document.documentElement).appendChild(scriptTag);
  }

  // bootstrap requires >= v1.9 of jquery
  function isOldVersion (jqVer) {
    var majorRel = jqVer.split('.')[0],
        minorRel = jqVer.split('.')[1];
    if (majorRel === '1' && parseInt(minorRel, 10) < 9) {
      return true;
    } else {
      return false;
    }
  }

  // there are two headers: visible-xs-block and hidden-xs
  // for auto-show behavior, the click event will be triggered on
  // all headers, including the hidden ones.
  // below two functions ensure only one toggle happens
  function isXsWidgetAndScreen($clickTarget) {
    var parent = $clickTarget.parent(),
        screenWidth = parseInt($clickTarget.closest('.cs-row').css('width'), 10);
    if (screenWidth <= 767 && parent.hasClass('visible-xs-block')) {
      return true;
    } else {
      return false;
    }
  }

  function isSmWidgetAndScreen($clickTarget) {
    var parent = $clickTarget.parent(),
        screenWidth = parseInt($clickTarget.closest('.cs-row').css('width'), 10);
    if (screenWidth > 767 && parent.hasClass('hidden-xs')) {
      return true;
    } else {
      return false;
    }
  }

  function slideDrawerPlugin ($container) {

    var drawer = {

      init: function (options, div) {

        if (options.showDrawer === true && options.slideTimeout === true) {
          setTimeout(function() {
            drawer.slide(div, options.drawerHiddenHeight, options.slideSpeed);
          }, options.slideTimeoutCount);
        } else if (options.showDrawer === 'slide') {
          // Set drawer hidden with slide effect
          drawer.slide(div, options.drawerHiddenHeight, options.slideSpeed);
        } else if (options.showDrawer === false) {
          // Set drawer to hide
          drawer.hide(options, div);
        }

        $container.find('.cs-header').on('click', function () {
          if ( isXsWidgetAndScreen($(this)) ) {
            drawer.toggle(options, div);
          } else if ( isSmWidgetAndScreen($(this)) ) {
            drawer.toggle(options, div);
          }
        });

      },
      toggle: function (options, div) {
        ($(div).height() + options.borderHeight === options.drawerHeight) ?
          drawer.slide( div, options.drawerHiddenHeight, options.slideSpeed ) :
          drawer.slide( div, options.drawerHeight-options.borderHeight, options.slideSpeed );
      },
      slide: function (div, height, speed) {
        $(div).animate({ 'height': height }, speed, 'swing', function () {
          $container.find('.cs-header i[class*="fa-chevron"]').toggle();
        });
      },
      hide: function (options, div) {
        $(div).css('height', options.drawerHiddenHeight);
      },

    };
    // Function wrapper
    $.fn.slideDrawer = function (options) {

      var $drawerContent = $container.find('.cs-drawer-content'),  /* Content height of drawer */
          borderHeight = parseInt($drawerContent.css('border-top-width')); /* Border height of content */

      var drawerHeight = this.height() + borderHeight; /* Total drawer height + border height */
      var drawerContentHeight = $drawerContent.outerHeight() //- borderHeight; /* Total drawer content height minus border top */
      var drawerHiddenHeight = (drawerHeight - drawerContentHeight) - borderHeight; /* How much to hide the drawer, total height minus content height */
      var defaults = {
        showDrawer: 'slide', /* Drawer hidden on load by default, options (true, false, slide) */
        slideSpeed: 700, /* Slide drawer speed 3 secs by default */
        slideTimeout: true, /* Sets time out if set to true showDrawer false will be ignored */
        slideTimeoutCount: 5000, /* How long to wait before sliding drawer */
        drawerContentHeight: drawerContentHeight, /* Div content height no including tab or border */
        drawerHeight: drawerHeight, /* Full div height */
        drawerHiddenHeight: drawerHiddenHeight, /* Height of div when hidden full height minus content height */
        borderHeight: borderHeight /* border height if set in css you cann overwrite but best just leave alone */
      };

      /* Overwrite defaults */
      var pluginOptions = $.extend(defaults, options);

      return this.each(function () {
        drawer.init(pluginOptions, this);
      });
    };

  }

  /*
    when scrolling past boundaries with trackpad, prevent default browser behavior
    (back/forward navigation)
  */
  function xScrollBoundaries (type) {
    // constraign trackpad scrolling (don't go forward/back in browser)
    var maxX = null;
    $(document).on('wheel',
      '#cs-container .row-horizon, #cs-tab-container .row-horizon, #cs-rel-container .row-horizon',
      function (event) {
        maxX = $(this).prop('scrollWidth') - $(this).prop('offsetWidth');
        // If this event looks like it will scroll beyond the bounds of the element,
        //  prevent it and set the scroll to the boundary manually
        if ($(this).prop('scrollLeft') + event.originalEvent.deltaX < 0 ||
            $(this).prop('scrollLeft') + event.originalEvent.deltaX > maxX) {
          event.preventDefault();
          $(this).prop('scrollLeft', Math.max(0, Math.min(maxX, $(this).prop('scrollLeft') + event.originalEvent.deltaX)));
        }
      }
    );
  }

  function scrollHandlers ($container) {

    var $carousel = $container.find('.row-horizon'),
        $paginationContainer = $container.find('.cs-pagination-row'),
        scrollWidth = $carousel.prop('scrollWidth'),
        maxScrollPosition = scrollWidth - $carousel.width(),
        numPages = Math.ceil(scrollWidth / $carousel.width()),
        pageWidth = Math.ceil(scrollWidth / numPages),
        currentPage = 1,
        scrollPosition = null, scrollRemaining = null,
        dynamicPage = null, lastPage = null,
        calculateDynamicPage = function (position, numPages, pageWidth, carouselWidth) {
          for (var i = 1; i <= numPages; i++) {
            if (position + (carouselWidth / 2) < pageWidth * i) { return i; }
          }
        },
        paginationTrackScroll = function () {
          dynamicPage =
            calculateDynamicPage($(this).scrollLeft(), numPages, pageWidth, $(this).width());
          if (dynamicPage !== currentPage) {
            lastPage = currentPage;
            currentPage = dynamicPage;
            $paginationContainer.find('div:nth-of-type(' + lastPage.toString() + ')')
                                .removeClass('cs-current-page-dot');
            $paginationContainer.find('div:nth-of-type(' + currentPage.toString() + ')')
                                .addClass('cs-current-page-dot');
          }
        },
        paginationScroll = function ($carousel, pageWidth, paginationTrackScroll) {
          // $(this) refers to the div.page-dot clicked
          return function (e) {
            var goToPage = null, scrollTo = null;

            if ($(this).hasClass('cs-current-page-dot')) { e.preventDefault(); }

            // turn off other handlers until animation is complete
            $carousel.off('scroll', paginationTrackScroll);
            // .. but not the currently executing handler ... things get weird
            // $('.cs-page-dot').off('click', paginationScroll)

            $(this).addClass('goto-page-dot');
            $container.find('.cs-current-page-dot').removeClass('cs-current-page-dot');
            $container.find('.cs-page-dot').each(function (index, pageDot) {
              if ($(this).hasClass('goto-page-dot')) {
                scrollTo = index * pageWidth;
                $(this).addClass('cs-current-page-dot')
                       .removeClass('goto-page-dot');
                return false;
              }
            });
            $carousel.animate({ scrollLeft: scrollTo }, 1000, function () {
              $carousel.on('scroll', paginationTrackScroll);
            });
          };
        },
        arrowScrollLeft = function ($carousel, pageWidth) {
          return function (e) {
            var scrollPosition = $carousel.scrollLeft(),
                $pageDots = $container.find('.cs-page-dot');
            $pageDots.off('click', paginationScroll);
            if (scrollPosition >= pageWidth) {
              $carousel.animate({ scrollLeft: '-=' + pageWidth.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
            else {
              $carousel.animate({ scrollLeft: '-=' + scrollPosition.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
          };
        },
        arrowScrollRight = function ($carousel, pageWidth, scrollWidth) {
          return function (e) {
            var scrollPosition = $carousel.scrollLeft(),
                scrollRemaining = scrollWidth - (scrollPosition + $carousel.width()),
                $pageDots = $container.find('.cs-page-dot');
            $pageDots.off('click', paginationScroll);
            if (scrollRemaining >= pageWidth) {
              $carousel.animate({ scrollLeft: '+=' + pageWidth.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            } else {
              $carousel.animate({ scrollLeft: '+=' + scrollRemaining.toString() }, 1000,
                function () { $pageDots.on('click', paginationScroll); });
            }
          };
        };

    // set up pagination
    for (var i = 0; i < numPages; i++) {
      if (i === 0) {
        $paginationContainer
          .append("<div class='cs-page-dot cs-current-page-dot'></div>");
      } else {
        $paginationContainer
          .append("<div class='cs-page-dot'></div>");
      }
    }

    if (numPages > 1) {

      $carousel.on('scroll', paginationTrackScroll);
      $container.find('.cs-scroll-left')
        .on('click', arrowScrollLeft($carousel, pageWidth));
      $container.find('.cs-scroll-right')
        .on('click', arrowScrollRight($carousel, pageWidth, scrollWidth));
      $container.find('.cs-page-dot')
        .on('click', paginationScroll($carousel, pageWidth, paginationTrackScroll));

    } else {
      $container.find('.cs-pagination-row, .cs-scroll-left, .cs-scroll-right')
        .css('visibility', 'hidden');
    }
  }

  function scrollHandlersExp ($container) {

    var $carousel = $container.find('.row-horizon'),
        scrollWidth = $carousel.prop('scrollWidth'),
        numPages = Math.ceil(scrollWidth / $carousel.width()),
        arrowScrollLeft = function ($carousel, pageWidth) {
          return function (e) {
            $carousel.animate({ scrollLeft: '-=' + $carousel.css('width') }, 500);
          };
        },
        arrowScrollRight = function ($carousel, pageWidth, scrollWidth) {
          return function (e) {
            $carousel.animate({ scrollLeft: '+=' + $carousel.css('width') }, 500)
          };
        };

    if (numPages > 1) {

      $container.find('.cs-scroll-left, .cs-scroll-left-xs')
                .on('click', arrowScrollLeft($carousel));
      $container.find('.cs-scroll-right, .cs-scroll-right-xs')
                .on('click', arrowScrollRight($carousel));

    } else {
      $container.find('.cs-scroll-left, .cs-scroll-left-xs, .cs-scroll-right, .cs-scroll-right-xs')
                .css('visibility', 'hidden');
    }
  }

  function trackVisitor () {

    $('#cs-container, #cs-tab-container, #cs-rel-container, #cs-rel-exp-container, #cs-varmour-container')
      .append('<iframe class="cs-iframe" height="0" width="0" style="display:none" ' +
              'src="https://' + '<%= @company.subdomain %>' + '.customerstories.net/widgets/track"></iframe>');

    // old approach:
    // var trackingDoc = $('#cs-container').find('iframe')[0].contentWindow.document,
    //     trackingHost = (("https:" == document.location.protocol) ? "https://s.adroll.com" : "http://a.adroll.com"),
    //     trackingUrl = trackingHost + '/j/roundtrip.js';
    // trackingDoc.open();
    // trackingDoc.write("<html><head><script>adroll_adv_id='" + advId + "';adroll_pix_id='" + pixId + "';</script><script src='" + trackingUrl + "'></script><script>setTimeout(function(){try{__adroll.record_user({'adroll_segments':'" + segmentId + "'})}catch(err){};},1000);</script></head></html>");
    // trackingDoc.close();
  }

  function setCookie (name, value, expires, path, domain, secure) {
    document.cookie = name + "=" + escape(value) +
      ((expires) ? "; expires=" + expires : "") +
      ((path) ? "; path=" + path : "") +
      ((domain) ? "; domain=" + domain : "") +
      ((secure) ? "; secure" : "");
  }

  function getCookie (name) {
    var cookie = " " + document.cookie;
    var search = " " + name + "=";
    var setStr = null;
    var offset = 0;
    var end = 0;
    if (cookie.length > 0) {
      offset = cookie.indexOf(search);
      if (offset != -1) {
        offset += search.length;
        end = cookie.indexOf(";", offset)
        if (end == -1) {
          end = cookie.length;
        }
        setStr = unescape(cookie.substring(offset, end));
      }
    }
    return(setStr);
  }

  // ref: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
  function hexToRgb (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
  }

  function textfillPlugin () {
    $.fn.textfill = function (options) {

      // Output arguments to the Debug console
      // if "Debug Mode" is enabled
      var _debug = function () {
        if (!Opts.debug
          ||  typeof console       == 'undefined'
          ||  typeof console.debug == 'undefined') {
          return;
        }
        console.debug.apply(console, arguments);
      }

      // Output arguments to the Warning console
      var _warn = function () {
        if (typeof console      == 'undefined' ||
          typeof console.warn == 'undefined') {
          return;
        }
        console.warn.apply(console, arguments);
      }

      // Outputs all information on the current sizing
      // of the font.
      var _debug_sizing = function (prefix, ourText, maxHeight, maxWidth, minFontPixels, maxFontPixels) {

        var _m = function (v1, v2) {

          var marker = ' / ';

          if (v1 > v2)
            marker = ' > ';

          else if (v1 == v2)
            marker = ' = ';

          return marker;
        }

        _debug(
          '[TextFill] '  + prefix + ' { ' +
          'font-size: ' + ourText.css('font-size') + ',' +
          'Height: '    + ourText.height() + 'px ' + _m(ourText.height(), maxHeight) + maxHeight + 'px,' +
          'Width: '     + ourText.width()  + _m(ourText.width() , maxWidth)  + maxWidth + ',' +
          'minFontPixels: ' + minFontPixels + 'px, ' +
          'maxFontPixels: ' + maxFontPixels + 'px }'
        );
      }

      /**
      * Calculates which size the font can get resized,
      * according to constrains.
      *
      * @param {String} prefix Gets shown on the console before
      *                        all the arguments, if debug mode is on.
      * @param {Object} ourText The DOM element to resize,
      *                         that contains the text.
      * @param {function} func Function called on `ourText` that's
      *                        used to compare with `max`.
      * @param {number} max Maximum value, that gets compared with
      *                     `func` called on `ourText`.
      * @param {number} minFontPixels Minimum value the font can
      *                               get resized to (in pixels).
      * @param {number} maxFontPixels Maximum value the font can
      *                               get resized to (in pixels).
      *
      * @return Size (in pixels) that the font can be resized.
      */
      var _sizing = function (prefix, ourText, func, max, maxHeight, maxWidth, minFontPixels, maxFontPixels) {

        _debug_sizing(
          prefix, ourText,
          maxHeight, maxWidth,
          minFontPixels, maxFontPixels
        );

        // The kernel of the whole plugin, take most attention
        // on this part.
        //
        // This is a loop that keeps increasing the `font-size`
        // until it fits the parent element.
        //
        // - Start from the minimal allowed value (`minFontPixels`)
        // - Guesses an average font size (in pixels) for the font,
        // - Resizes the text and sees if its size is within the
        //   boundaries (`minFontPixels` and `maxFontPixels`).
        //   - If so, keep guessing until we break.
        //   - If not, return the last calculated size.
        //
        // I understand this is not optimized and we should
        // consider implementing something akin to
        // Daniel Hoffmann's answer here:
        //
        //     http://stackoverflow.com/a/17433451/1094964
        //

        while (minFontPixels < (maxFontPixels - 1)) {

          var fontSize = Math.floor((minFontPixels + maxFontPixels) / 2);
          ourText.css('font-size', fontSize);

          if (func.call(ourText) <= max) {
            minFontPixels = fontSize;

            if (func.call(ourText) == max)
              break;
          }
          else
            maxFontPixels = fontSize;

          _debug_sizing(
            prefix, ourText,
            maxHeight, maxWidth,
            minFontPixels, maxFontPixels
          );
        }

        ourText.css('font-size', maxFontPixels);

        if (func.call(ourText) <= max) {
          minFontPixels = maxFontPixels;

          _debug_sizing(
            prefix + '* ', ourText,
            maxHeight, maxWidth,
            minFontPixels, maxFontPixels
          );
        }
        return minFontPixels;
      }

      // Merging user options with the default values
      var defaults = {
        debug            : false,
        maxFontPixels    : 40,
        minFontPixels    : 4,
        innerTag         : 'span',
        widthOnly        : false,
        success          : null, // callback when a resizing is done
        callback         : null, // callback when a resizing is done (deprecated, use success)
        fail             : null, // callback when a resizing is failed
        complete         : null, // callback when all is done
        explicitWidth    : null,
        explicitHeight   : null,
        changeLineHeight : false
      };

      var Opts = $.extend(defaults, options);

      _debug('[TextFill] Start Debug');

      this.each(function() {

        // Contains the child element we will resize.
        // $(this) means the parent container
        var ourText = $(Opts.innerTag + ':visible:first', this);

        // Will resize to this dimensions.
        // Use explicit dimensions when specified
        var maxHeight = Opts.explicitHeight || $(this).height();
        var maxWidth  = Opts.explicitWidth  || $(this).width();

        var oldFontSize = ourText.css('font-size');

        var lineHeight  = parseFloat(ourText.css('line-height')) / parseFloat(oldFontSize);

        _debug('[TextFill] Inner text: ' + ourText.text());
        _debug('[TextFill] All options: ', Opts);
        _debug('[TextFill] Maximum sizes: { ' +
             'Height: ' + maxHeight + 'px, ' +
             'Width: '  + maxWidth  + 'px' + ' }'
            );

        var minFontPixels = Opts.minFontPixels;

        // Remember, if this `maxFontPixels` is negative,
        // the text will resize to as long as the container
        // can accomodate
        var maxFontPixels = (Opts.maxFontPixels <= 0 ?
                   maxHeight :
                   Opts.maxFontPixels);


        // Let's start it all!

        // 1. Calculate which `font-size` would
        //    be best for the Height
        var fontSizeHeight = undefined;

        if (! Opts.widthOnly)
          fontSizeHeight = _sizing(
            'Height', ourText,
            $.fn.height, maxHeight,
            maxHeight, maxWidth,
            minFontPixels, maxFontPixels
          );

        // 2. Calculate which `font-size` would
        //    be best for the Width
        var fontSizeWidth = undefined;

        fontSizeWidth = _sizing(
          'Width', ourText,
          $.fn.width, maxWidth,
          maxHeight, maxWidth,
          minFontPixels, maxFontPixels
        );

        // 3. Actually resize the text!

        if (Opts.widthOnly) {
          ourText.css({
            'font-size'  : fontSizeWidth,
            'white-space': 'nowrap'
          });

          if (Opts.changeLineHeight)
            ourText.parent().css(
              'line-height',
              (lineHeight * fontSizeWidth + 'px')
            );
        }
        else {
          var fontSizeFinal = Math.min(fontSizeHeight, fontSizeWidth);

          ourText.css('font-size', fontSizeFinal);

          if (Opts.changeLineHeight)
            ourText.parent().css(
              'line-height',
              (lineHeight * fontSizeFinal) + 'px'
            );
        }

        _debug(
          '[TextFill] Finished { ' +
          'Old font-size: ' + oldFontSize              + ', ' +
          'New font-size: ' + ourText.css('font-size') + ' }'
        );

        // Oops, something wrong happened!
        // We weren't supposed to exceed the original size
        if ((ourText.width()  > maxWidth) ||
          (ourText.height() > maxHeight && !Opts.widthOnly)) {

          ourText.css('font-size', oldFontSize);

          // Failure callback
          if (Opts.fail)
            Opts.fail(this);

          _debug(
            '[TextFill] Failure { ' +
            'Current Width: '  + ourText.width()  + ', ' +
            'Maximum Width: '  + maxWidth         + ', ' +
            'Current Height: ' + ourText.height() + ', ' +
            'Maximum Height: ' + maxHeight        + ' }'
          );
        }
        else if (Opts.success) {
          Opts.success(this);
        }
        else if (Opts.callback) {
          _warn('callback is deprecated, use success, instead');

          // Success callback
          Opts.callback(this);
        }
      });

      // Complete callback
      if (Opts.complete)
        Opts.complete(this);

      _debug('[TextFill] End Debug');
      return this;
    }
  }

}(window, document));

